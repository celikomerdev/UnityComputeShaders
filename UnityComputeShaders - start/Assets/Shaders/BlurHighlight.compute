

shared Texture2D<float4> source;
shared RWTexture2D<float4> blurOutput;
RWTexture2D<float4> output;
float radius;
float edgeWidth;
float shade;
float4 center;
int blurRadius;


float inCircle( float2 pt, float2 center, float radius, float edgeWidth )
{
	float len = length(pt - center);
	return 1.0 - smoothstep(radius-edgeWidth, radius, len);
}



#pragma kernel BlurPass
[numthreads(8, 8, 1)]
void BlurPass(uint3 id : SV_DispatchThreadID)
{
	float4 color = 0;
	blurOutput[id.xy] = 0;
	
	color = 0;
	int left = max(0,(int)id.x-blurRadius);
	int right = min(source.Length.x,(int)id.x+blurRadius);
	for (int x=left; x<right; x++)
	{
		color += source[int2(x,id.y)];
	}
	blurOutput[id.xy] += color/(abs(left-right)*2.0f);
	
	color = 0;
	int bottom = max(0,(int)id.y-blurRadius);
	int top = min(source.Length.y,(int)id.y+blurRadius);
	for (int y=bottom; y<top; y++)
	{
		color += source[int2(id.x,y)];
	}
	blurOutput[id.xy] += color/(abs(bottom-top)*2.0f);
}

#pragma kernel Highlight
[numthreads(8, 8, 1)]
void Highlight(uint3 id : SV_DispatchThreadID)
{
	float4 sourceColor = source[id.xy];
	float4 shadedSourceColor = blurOutput[id.xy]*shade;
	float highlight = inCircle(id.xy,center.xy,radius,edgeWidth);
	float4 color = lerp(shadedSourceColor,sourceColor,highlight);
	output[id.xy] = color;
}