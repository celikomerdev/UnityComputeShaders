
Texture2D<float4> source;
RWTexture2D<float4> output;
float radius;
float edgeWidth;
int lines;
float4 tintColor;
float tintStrength;
float time;

float random(float2 pt, float seed)
{
	const float a = 12.9898;
	const float b = 78.233;
	const float c = 43758.543123;
	return frac(sin(dot(pt, float2(a, b)) + seed) * c );
}

float inCircle(float2 pt, float2 center, float radius, float edgeWidth)
{
	float len = length(pt - center);
	return 1.0 - smoothstep(radius-edgeWidth, radius, len);
}

#pragma kernel CSMain
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
	float noise = random(id.xy,time);
	uint2 index = (id.xy/3)*3;
	float3 finalColor = lerp(source[id.xy].rgb,source[index].rgb*0.5f,noise);
	float3 grayscale = (finalColor.r+finalColor.g+finalColor.b)/3.0f;
	float3 tinted = grayscale*tintColor;
	finalColor = lerp(finalColor,tinted,tintStrength);
	
	
	float uvY = id.y/(float)source.Length.y;
	float scanLine = saturate(smoothstep(0.1f,0.2f,frac(uvY*lines + time*3)));
	finalColor = lerp(source[id.xy]*0.5f,finalColor,scanLine);
	
	
	float2 center = float2(source.Length*0.5f);
	float highlightL = inCircle(id.xy,float2(center.x*0.75f,center.y),radius,edgeWidth);
	float highlightR = inCircle(id.xy,float2(center.x*1.25f,center.y),radius,edgeWidth);
	
	float highlightCombined = saturate(highlightL+highlightR);
	finalColor = lerp(0,finalColor,highlightCombined);
	
	// output[id.xy] = scanLine;
	output[id.xy] = float4(finalColor, 1);
}